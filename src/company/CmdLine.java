package company;

import java.io.*;
import java.nio.file.*;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.Scanner;

public class CmdLine {
    public static boolean cmdExecute(String cmdLine) {
        String[] cmdLineArray = cmdLine.split("\\s");
        String cmd = cmdLineArray[0];
        String path = "";
        boolean isExit = false;
        if (cmdLineArray.length >= 2) {
            path = cmdLineArray[1];
        }
        switch (cmd) {
            case "ls":
                MyFile.listDirectory(path);
                break;
            case "ls_py":
                MyFile.listPythonFiles(path);
                break;
            case "is_dir":
                MyFile.isDirectory(path);
                break;
            case "define":
                MyFile.define(path);
                break;
            case "readmod":
                MyFile.printPermissions(path);
                break;
            case "setmod":
                if (cmdLineArray.length == 3) {
                    MyFile.setPermissions(path, cmdLineArray[2]);
                } else {
                    System.out.println("Ошибка! не правильно использованна команда, чтобы " +
                            "ознакомиться с командами введите help");
                }
                break;
            case "cat":
                MyFile.printContent(path);
                break;
            case "append":
                MyFile.appendFooter(path);
                break;
            case "bc":
                MyFile.createBackup(path);
                break;
            case "greplong":
                MyFile.printLongestWord(path);
                break;
            case "help":
                MyFile.help();
                break;
            case "exit":
                MyFile.exit();
                isExit = true;
                break;
            default:
                System.out.println("Ошибка! Команда не существует чтобы ознакомиться с командами введите help");

        }
        return isExit;
    }
}

class MyFile {
    public static void listDirectory(String path) {
        File file = new File(path);
        if (checkExistingPath(file)) {
            return;
        }
        File currentDir = new File(path);
        String[] files = currentDir.list();
        for (String name : files) {
            System.out.println(name);
        }
    }
    public static void listPythonFiles(String path) {
        File file = new File(path);
        if (checkExistingPath(file)) {
            return;
        }
        File currentDir = new File(path);
        String[] files = currentDir.list(new FilenameFilter() {
            @Override
            public boolean accept(File dir, String name) {
                return name.endsWith(".py");
            }
        });
        for (String name : files) {
            System.out.println(name);
        }
    }
    public static void isDirectory(String path) {
        File file = new File(path);
        if (checkExistingPath(file)) {
            return;
        }
        File currentDir = new File(path);
        System.out.println(currentDir.isDirectory());
    }
    public static void define(String path) {
        File currentDir = new File(path);
        if (currentDir.isDirectory())       System.out.println("директория");
        if (currentDir.isFile())            System.out.println("файл");
    }
    public static void printPermissions(String path) {
        File file = new File(path);
        if (checkExistingPath(file)) {
            return;
        }
        File currentDir = new File(path);
        String permissions = "";
        if (currentDir.canRead()) permissions += "r";       else permissions += "-";
        if (currentDir.canWrite()) permissions += "w";      else permissions += "-";
        if (currentDir.canExecute()) permissions += "x";    else permissions += "-";
        System.out.println(permissions);
    }
    public static void setPermissions(String path, String permissions) {
        File file = new File(path);
        if (checkExistingPath(file)) {
            return;
        }
        File currentDir = new File(path);
        currentDir.setReadable(permissions.charAt(0) == 'r');
        currentDir.setWritable(permissions.charAt(1) == 'w');
        currentDir.setExecutable(permissions.charAt(2) == 'x');
    }
    public static void printContent(String path) {
        Scanner input = null;
        File file = new File(path);
        if (checkExistingPath(file)) {
            return;
        }
        try {
            input = new Scanner(new File(path));
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }

        while (input.hasNextLine())
        {
            System.out.println(input.nextLine());
        }
    }
    public static void appendFooter(String path) {
        String str = "# Autogenerated line";
        File file = new File(path);
        if (checkExistingPath(file)) {
            return;
        }
        BufferedWriter writer = null;
        try {
            writer = new BufferedWriter(new FileWriter(path, true));
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            writer.append(' ');
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            writer.append(str);
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            writer.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    public static void createBackup(String path) {
        File file = new File(path);
        if (checkExistingPath(file)) {
            return;
        }
        DateTimeFormatter df = DateTimeFormatter.ofPattern("dd-MM-yyy");
        LocalDate localDate = LocalDate.now();
        File dest = new File("/tmp/" + df.format(localDate) + ".backup");
        if(dest.exists()) {
            try {
                deleteDirectoryRecursion(dest.toPath());
            } catch (IOException e) {
                e.printStackTrace();
            }
        }

        if(file.isFile()) {
            dest.mkdir();
            try {
                InputStream in = new BufferedInputStream(new FileInputStream(file));
                OutputStream out = new BufferedOutputStream(new FileOutputStream(dest + "/" + file.getName()));
                byte[] buffer =new byte[1024];
                int len;
                while ((len = in.read(buffer)) > 0) {
                    out.write(buffer,0,len);
                    out.flush();
                }
            }catch (IOException e) {
                e.printStackTrace();
            }
            return;
        }



        Path sourcePath = file.toPath();
        Path destPath = dest.toPath();

        try {
            Files.walk(sourcePath).forEach((s) -> copy(s, destPath.resolve(sourcePath.relativize(s))));
        } catch (IOException e) {
            e.printStackTrace();
        }


    }

    private static void deleteDirectoryRecursion(Path path) throws IOException {
        if (Files.isDirectory(path, LinkOption.NOFOLLOW_LINKS)) {
            try (DirectoryStream<Path> entries = Files.newDirectoryStream(path)) {
                for (Path entry : entries) {
                    deleteDirectoryRecursion(entry);
                }
            }
        }
        Files.delete(path);
    }
    private static void copy(Path source, Path dest) {
        try {
            Files.copy(source, dest, StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void printLongestWord(String path) {
        File file = new File(path);

        if (checkExistingPath(file)) {
            return;
        }
        if (file.isDirectory()) {
            System.out.println("Это директория, читать можно только файл");
            return;
        }

        try {
            BufferedReader reader = new BufferedReader(new FileReader(file));
            String strCurrentLine;
            String longest = "";
            while ((strCurrentLine = reader.readLine()) != null) {
                if(longest.length() < strCurrentLine.length()) {
                    longest = strCurrentLine;
                }
            }
            System.out.println(longest);
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static void help() {
        System.out.println("ls <path>               выводит список всех файлов и директорий для `path`\n" +
                "ls_py <path>            выводит список файлов с расширением `.py` в `path`\n" +
                "is_dir <path>           выводит `true`, если `path` это директория, в других случаях `false`\n" +
                "define <path>           выводит `директория` или `файл` в зависимости от типа `path`\n" +
                "readmod <path>          выводит права для файла в формате `rwx` для текущего пользователя\n" +
                "setmod <path> <perm>    устанавливает права для файла `path`\n" +
                "cat <path>              выводит контент файла\n" +
                "append <path>           добавляет строку `# Autogenerated line` в конец `path`\n" +
                "bc <path>               создает копию `path` в директорию `/tmp/${date}.backup` где, date - это дата в формате `dd-mm-yyyy`\n" +
                "greplong <path>         выводит самое длинное слово в файле\n" +
                "help                    выводит список команд и их описание\n" +
                "exit                    завершает работу программы");
    }

    // завершает работу программы - exit
    public static void exit() {
        System.out.println("Goodbye");
    }
    private static boolean checkExistingPath(File file) {
        if (!file.exists()) {
            System.out.println("Указанный путь не существует");
            return true;
        }
        return false;
    }
}